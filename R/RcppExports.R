# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rig <- function(mu) {
    .Call(`_SUFA_rig`, mu)
}

#' Matrix inversion using low-rank plus diagonal decomposition
#'
#' Fast inversion of \eqn{\Sigma=\Lambda \Lambda^T+\mathrm{diag}(\texttt{ps})} using the \href{https://en.wikipedia.org/wiki/Woodbury_matrix_identity}{Woodbury matrix identity}
#'
#' @param Lambda A \eqn{d \times q} order matrix \eqn{\Lambda} typically \eqn{q\ll d} 
#' @param ps A vector of length \eqn{d} comprising positive elements
#'
#' @return The matrix \eqn{(\Lambda \Lambda^T+\mathrm{diag}(\texttt{ps}) )^{-1}}
#' @export
#'
#' @examples
#' d=1e3; q=50
#' lam=matrix(rnorm(d*q,sd=.25),nrow=d,ncol=q ); ps=rgamma(d,1,1) 
#' sig=tcrossprod(lam)+diag(ps)
#' rbenchmark::benchmark( chol2inv(chol(sig )),##Cholesky based inverse
#'  fast_fact_inv(lam,ps), ##fast_fact_inv
#'  replications = 10  ##benchmark using 10 replicates
#'  ) 
fast_fact_inv <- function(Lambda, ps) {
    .Call(`_SUFA_fast_fact_inv`, Lambda, ps)
}

#' Determinant of a matrix using low-rank plus diagonal decomposition
#'
#' Fast determinant of \eqn{\Sigma=\Lambda \Lambda^T+\mathrm{diag}(\texttt{ps})} using the \href{https://en.wikipedia.org/wiki/Matrix_determinant_lemma}{Matrix determinant lemma}
#'
#' @param Lambda_orig A \eqn{d \times q} order matrix \eqn{\Lambda} typically \eqn{q\ll d} 
#' @param ps A vector of length \eqn{d} comprising positive elements
#' @param lg A logical variable; if \code{TRUE} (default), \code{log} of the determinant will be returned.
#'
#' @return If \code{lg=TRUE} then \code{log}-determinant of \eqn{\Lambda \Lambda^T+\mathrm{diag}(\texttt{ps}) }; else determinant of \eqn{\Lambda \Lambda^T+\mathrm{diag}(\texttt{ps}) }.
#' @export
#'
#' @examples
#' d=1e3; q=50
#' lam=matrix(rnorm(d*q,sd=.25),nrow=d,ncol=q ); ps=rgamma(d,1,1) 
#' sig=tcrossprod(lam)+diag(ps)
#' rbenchmark::benchmark( log(det(sig)), ##naive determinant
#' 2*sum(log(diag(chol(sig ))) ),##Cholesky based determinant
#'  fast_fact_det(lam,ps), ##fast_fact_det
#'  replications = 10  ##benchmark using 10 replicates
#'  ) 
fast_fact_det <- function(Lambda_orig, ps, lg = 1L) {
    .Call(`_SUFA_fast_fact_det`, Lambda_orig, ps, lg)
}

#' Cholesky factorization based fast determinant of positive defnite matrices
#'
#' @param X A positive definite matrix
#' @param lg A logical variable; if \code{TRUE} (default), \code{log} of the determinant will be returned.
#'
#' @return If \code{lg=TRUE} then \code{log}-determinant of \code{X}; else determinant of \code{X}
#' @export
log_det_pd <- function(X, lg = 1L) {
    .Call(`_SUFA_log_det_pd`, X, lg)
}

cov_est_HMC <- function(a, ps_hyper, nrun, thin, nleapfrog, del_range, phimat, Y, leapmin = 5L, leapmax = 15L) {
    .Call(`_SUFA_cov_est_HMC`, a, ps_hyper, nrun, thin, nleapfrog, del_range, phimat, Y, leapmin, leapmax)
}

cov_est_Gibbs <- function(as, bs, a, nrun, burn, thin, phimat, eta, Y) {
    .Call(`_SUFA_cov_est_Gibbs`, as, bs, a, nrun, burn, thin, phimat, eta, Y)
}

SUFA_HMC <- function(nrun, thin, nleapfrog, del_range, ps_hyper, A_hyper, a, Y_list, ks, phi_init, leapmax = 18L, leapmin = 5L, col_prob = 1.0, nthreads = 4L) {
    .Call(`_SUFA_SUFA_HMC`, nrun, thin, nleapfrog, del_range, ps_hyper, A_hyper, a, Y_list, ks, phi_init, leapmax, leapmin, col_prob, nthreads)
}

matchalign_permmat <- function(lambda, pivot) {
    .Call(`_SUFA_matchalign_permmat`, lambda, pivot)
}

